<?xml version="1.0"?>

<!-- Copyright (c) 2006  Dustin Sallings (dustin@spy.net) -->

<document>
	<properties>
		<author email="dustin@spy.net">Dustin Sallings</author>
		<title>java memcached client</title>
	</properties>

	<body>
		<section name="Overview">
			<p>
				This is a simple, asynchronous, single-threaded memcached client
				written in java.
			</p>
			<h2>Features</h2>
			<ul>
				<li>
					<strong>Efficient storage of objects.</strong>
					General serializable objects are stored in their serialized form and
					optionally compressed if they meet criteria.  Certain native objects
					are stored as tightly as possible (for example, a Date object
					generally consumes six bytes, and a Long can be anywhere from zero to
					eight bytes).
				</li>
				<li>
					<strong>Resilient to server and network outages.</strong>
					In many cases, a client operation can be replayed against a server if
					it goes away and comes back.  In cases where it can't, it will
					communicate that as well.  An exponential backoff reconnect algorithm
					is applied when a memcached becomes unavailable, but asynchronous
					operations will queue up for the server to be applied when it comes
					back online.
				</li>
				<li>
					<strong>Operations are asynchronous.</strong>
					It is possible to issue a store and continue processing without
					having to wait for that operation to finish.  It is even possible to
					issue a get, do some further processing, check the result of the get
					and cancel it if it doesn't return fast enough.
				</li>
				<li>
					<strong>There is only one thread for all processing.</strong>
					Regardless of the number of requests, threads using the client, or
					servers to which the client is connected, only one thread will ever
					be allocated to a given MemcachedClient.
				</li>
				<li>
					<strong>Aggressively optimized.</strong>
					There are <a href="optimization.html">many optimizations</a> that
					combine to provide high throughput.
				</li>
			</ul>
		</section>
		<section name="Example Usage">
			<p>
				Below are some getting-started examples of how to use the memcached
				client to store and retrieve objects.  See the <a
				href="apidocs/index.html">the API docs</a> for more details, in
				particular the documentation for the <a
				href="apidocs/net/spy/memcached/MemcachedClient.html">MemcachedClient</a>
				class.
			</p>
			<h2>Basic Usage</h2>
<source>
MemcachedClient c=new MemcachedClient(
    new InetSocketAddress("hostname", portNum));

// Store a value (async) for one hour
c.set("someKey", 3600, someObject);
// Retrieve a value (synchronously).
Object myObject=c.get("someKey");
</source>

			<h2>Advanced Usage</h2>
			<p>
			MemcachedClient may be processing a great deal of asynchronous messages
			or possibly dealing with an unreachable memcached, which may delay
			processing. If a memcached is disabled, for example, MemcachedConnection
			will continue to attempt to reconnect and replay pending operations until
			it comes back up. To prevent this from causing your application to hang,
			you can use one of the asynchronous mechanisms to time out a request and
			cancel the operation to the server.
			</p>
<source>
// Get a memcached client connected to several servers
MemcachedClient c=new MemcachedClient(
	AddrUtil.getAddresses("server1:11211 server2:11211"));

// Try to get a value, for up to 5 seconds, and cancel if it doesn't return
Object myObj=null;
Future&lt;Object> f=c.asyncGet("someKey");
try {
    myObj=f.get(5, TimeUnit.SECONDS);
} catch(TimeoutException e) {
    // Since we don't need this, go ahead and cancel the operation.  This
    // is not strictly necessary, but it'll save some work on the server.
    f.cancel(false);
    // Do other timeout related stuff
}
</source>
		<h2>Binary Protocol Support</h2>
		<p>
			As of release 2.0, the new binary wire protocol for memcached is
			supported.  Below is an example of how you might connect to a server
			using the binary protocol:
		</p>
<source>
// Get a memcached client connected to several servers with the binary protocol
MemcachedClient c=new MemcachedClient(
	new BinaryConnectionFactory(),
	AddrUtil.getAddresses("server1:11212 server2:11212"));

// Proceed to do cool stuff with memcached using the binary protocol.
</source>
		</section>
		<section name="Where to Get">
			<h3>Binary Distributions</h3>
			<p>
				You can fetch one of the <a href="downloads.html">official
				releases</a>, or rummage through my
				<a href="http://bleu.west.spy.net/~dustin/repo/">maven 1
				repository</a>.
			</p>
			<p>
				If you use maven 1, you can just add my repo to your list:
			</p>
			<blockquote>
				<p>http://bleu.west.spy.net/~dustin/repo/</p>
			</blockquote>
			<h3>Source Code</h3>
			<p>
				The source can be downloaded or checked out from my
				<a href="http://github.com/dustin/java-memcached-client/tree">git
				repository</a>.
			</p>
			<h3>Dependencies</h3>
			<p>
				Note that this also requires
				<a href="http://bleu.west.spy.net/~dustin/projects/spyjar/">spy.jar</a>
				(2.4 or so) from the same repository.
			</p>
		</section>
		<section name="License">
			<p>
				This project is released under the
				<a href="http://www.opensource.org/licenses/mit-license.php">MIT</a>
				license.
			</p>
		</section>
	</body>
</document>
